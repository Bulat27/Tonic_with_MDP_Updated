// USS_HEAP_H
// // File: MinHeapSpaceSaving.h
// #ifndef MIN_HEAP_SPACE_SAVING_H
// #define MIN_HEAP_SPACE_SAVING_H

// #include <vector>
// #include <unordered_map>
// #include <algorithm>
// #include <random>
// #include <utility>

// class MinHeapSpaceSaving {
// public:
//     MinHeapSpaceSaving(int k, int seed)
//     : capacity_(k), gen_(seed), dist_(0.0, 1.0)
// {
//     heap_.reserve(k);
//     node_to_index_.reserve(k);
// }

//     void update(int node) {
//         if (node_to_index_.count(node)) {
//             int idx = node_to_index_[node];
//             heap_[idx].freq++;
//             sift_down(idx);
//         } else if ((int)heap_.size() < capacity_) {
//             heap_.push_back({node, 1});
//             node_to_index_[node] = heap_.size() - 1;
//             sift_up(heap_.size() - 1);
//         } else {
//             int min_idx = 0;
//             int min_freq = heap_[min_idx].freq;
//             double prob = 1.0 / (min_freq + 1);
//             if (dist_(gen_) < prob) {
//                 int evicted_node = heap_[min_idx].node;
//                 node_to_index_.erase(evicted_node);
//                 heap_[min_idx] = {node, min_freq + 1};
//                 node_to_index_[node] = min_idx;
//                 sift_down(min_idx);
//             }
//         }
//     }

//     std::vector<std::pair<int, int>> top_k() const {
//         std::vector<std::pair<int, int>> res;
//         for (const auto &h : heap_) {
//             res.emplace_back(h.node, h.freq);
//         }
//         return res;
//     }

// private:
//     struct HeapNode {
//         int node;
//         int freq;
//     };

//     int capacity_;
//     std::vector<HeapNode> heap_;
//     std::unordered_map<int, int> node_to_index_;
//     std::mt19937 gen_;
//     std::uniform_real_distribution<double> dist_;

//     int parent(int i) { return (i - 1) / 2; }
//     int left(int i) { return 2 * i + 1; }
//     int right(int i) { return 2 * i + 2; }

//     void sift_up(int i) {
//         while (i > 0 && heap_[parent(i)].freq > heap_[i].freq) {
//             swap_nodes(i, parent(i));
//             i = parent(i);
//         }
//     }

//     void sift_down(int i) {
//         int n = heap_.size();
//         while (true) {
//             int l = left(i), r = right(i), smallest = i;
//             if (l < n && heap_[l].freq < heap_[smallest].freq) smallest = l;
//             if (r < n && heap_[r].freq < heap_[smallest].freq) smallest = r;
//             if (smallest != i) {
//                 swap_nodes(i, smallest);
//                 i = smallest;
//             } else break;
//         }
//     }

//     void swap_nodes(int i, int j) {
//         std::swap(heap_[i], heap_[j]);
//         node_to_index_[heap_[i].node] = i;
//         node_to_index_[heap_[j].node] = j;
//     }
// };

// #endif