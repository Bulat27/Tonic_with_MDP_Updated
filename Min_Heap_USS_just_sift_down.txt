// File: USSHeap.h
#ifndef USS_HEAP_H
#define USS_HEAP_H

#include <vector>
#include <unordered_map>
#include <random>
#include <utility>
#include <cassert>

class MinHeapSpaceSaving {
public:
    MinHeapSpaceSaving(int k, int seed)
        : capacity_(k), gen_(seed), dist_(0.0, 1.0) {
        heap_.resize(k, {-1, 0});  // dummy node: -1 means unused
    }

    void update(int node) {
        auto it = node_to_index_.find(node);
        if (it != node_to_index_.end()) {
            int i = it->second;
            heap_[i].freq++;
            sift_down(i);
        } else {
            int min_idx = 0;
            if (heap_[min_idx].node == -1) {
                // Place new node at root
                heap_[min_idx] = {node, 1};
                node_to_index_[node] = min_idx;
                sift_down(min_idx);
            } else {
                int min_freq = heap_[min_idx].freq;
                double prob = 1.0 / (min_freq + 1);
                if (dist_(gen_) < prob) {
                    int evicted = heap_[min_idx].node;
                    node_to_index_.erase(evicted);
                    heap_[min_idx] = {node, min_freq + 1};
                    node_to_index_[node] = min_idx;
                    sift_down(min_idx);
                }
            }
        }
    }

    std::vector<std::pair<int, int>> top_k() const {
        std::vector<std::pair<int, int>> res;
        for (const auto& h : heap_) {
            if (h.node != -1)
                res.emplace_back(h.node, h.freq);
        }
        return res;
    }

//     std::vector<std::pair<int, int>> top_k_sorted(int k) const {
//     std::vector<std::pair<int, int>> res;
//     for (const auto& h : heap_) {
//         if (h.node != -1)
//             res.emplace_back(h.node, h.freq);
//     }

//     // Sort in descending order by frequency
//     std::sort(res.begin(), res.end(), [](const auto& a, const auto& b) {
//         return a.second > b.second;  // descending
//     });

//     // Truncate to top k
//     if ((int)res.size() > k) {
//         res.resize(k);
//     }
//     return res;
// }

private:
    struct HeapNode {
        int node;
        int freq;
    };

    int capacity_;
    std::vector<HeapNode> heap_;
    std::unordered_map<int, int> node_to_index_;
    std::mt19937 gen_;
    std::uniform_real_distribution<double> dist_;

    int left(int i) const { return 2 * i + 1; }
    int right(int i) const { return 2 * i + 2; }

    void sift_down(int i) {
        int n = capacity_;
        while (true) {
            int l = left(i), r = right(i), smallest = i;
            if (l < n && heap_[l].freq < heap_[smallest].freq) smallest = l;
            if (r < n && heap_[r].freq < heap_[smallest].freq) smallest = r;
            if (smallest != i) {
                swap_nodes(i, smallest);
                i = smallest;
            } else break;
        }
    }

    void swap_nodes(int i, int j) {
        std::swap(heap_[i], heap_[j]);
        node_to_index_[heap_[i].node] = i;
        node_to_index_[heap_[j].node] = j;
    }
};

#endif